{
  "metadata": {
    "source": "LeetCode GraphQL API",
    "crawl_time": "2025-11-02T17:35:31.548755",
    "total_problems": 50,
    "version": "3.0"
  },
  "problems": [
    {
      "question": {
        "translatedTitle": "两数之和",
        "translatedContent": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>&nbsp; 的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回它们的数组下标。</p>\n\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n\n<p>你可以按任意顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,4], target = 6\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3], target = 6\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>\n",
        "description": "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [2,7,11,15], target = 9",
            "output": "[0,1]",
            "explanation": "因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。",
            "raw_content": "输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。"
          },
          {
            "title": "示例 2",
            "input": "nums = [3,2,4], target = 6",
            "output": "[1,2]",
            "explanation": "",
            "raw_content": "输入：nums = [3,2,4], target = 6\n输出：[1,2]"
          },
          {
            "title": "示例 3",
            "input": "nums = [3,3], target = 6",
            "output": "[0,1]",
            "explanation": "",
            "raw_content": "输入：nums = [3,3], target = 6\n输出：[0,1]"
          }
        ],
        "constraints": "2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案",
        "followUp": "你可以想出一个时间复杂度小于 O(n2) 的算法吗？",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          }
        ],
        "hints": [
          "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.",
          "So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "exampleTestcases": "[2,7,11,15]\n9\n[3,2,4]\n6\n[3,3]\n6",
        "sampleTestCase": "[2,7,11,15]\n9",
        "jsonExampleTestcases": "[\"[2,7,11,15]\\n9\", \"[3,2,4]\\n6\", \"[3,3]\\n6\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "两数相加",
        "translatedContent": "<p>给你两个&nbsp;<strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照&nbsp;<strong>逆序</strong>&nbsp;的方式存储的，并且每个节点只能存储&nbsp;<strong>一位</strong>&nbsp;数字。</p>\n\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,0,8]\n<strong>解释：</strong>342 + 465 = 807.\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>输出：</strong>[8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n",
        "description": "给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。",
        "examples": [
          {
            "title": "示例 1",
            "input": "l1 = [2,4,3], l2 = [5,6,4]",
            "output": "[7,0,8]",
            "explanation": "342 + 465 = 807.",
            "raw_content": "输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807."
          },
          {
            "title": "示例 2",
            "input": "l1 = [0], l2 = [0]",
            "output": "[0]",
            "explanation": "",
            "raw_content": "输入：l1 = [0], l2 = [0]\n输出：[0]"
          },
          {
            "title": "示例 3",
            "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
            "output": "[8,9,9,9,0,0,0,1]",
            "explanation": "",
            "raw_content": "输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]"
          }
        ],
        "constraints": "每个链表中的节点数在范围 [1, 100] 内\n0 <= Node.val <= 9\n题目数据保证列表表示的数字不含前导零",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          }
        ],
        "hints": [],
        "exampleTestcases": "[2,4,3]\n[5,6,4]\n[0]\n[0]\n[9,9,9,9,9,9,9]\n[9,9,9,9]",
        "sampleTestCase": "[2,4,3]\n[5,6,4]",
        "jsonExampleTestcases": "[\"[2,4,3]\\n[5,6,4]\", \"[0]\\n[0]\", \"[9,9,9,9,9,9,9]\\n[9,9,9,9]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "无重复字符的最长子串",
        "translatedContent": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长 <span data-keyword=\"substring-nonempty\">子串</span></strong><strong>&nbsp;</strong>的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"abcabcbb\"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\"abc\"</code>，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"bbbbb\"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"b\"</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"pwwkew\"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>\"wke\"</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>\"pwke\"</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>\n</ul>\n",
        "description": "给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n \n示例 1:\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。\n\n示例 2:\n\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n示例 3:\n\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"abcabcbb\"",
            "output": "3",
            "explanation": "因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。",
            "raw_content": "输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。"
          },
          {
            "title": "示例 2",
            "input": "s = \"bbbbb\"",
            "output": "1",
            "explanation": "因为无重复字符的最长子串是 \"b\"，所以其长度为 1。",
            "raw_content": "输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。"
          },
          {
            "title": "示例 3",
            "input": "s = \"pwwkew\"",
            "output": "3",
            "explanation": "因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。",
            "raw_content": "输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。"
          }
        ],
        "constraints": "0 <= s.length <= 5 * 104\ns 由英文字母、数字、符号和空格组成",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Sliding Window",
            "nameTranslated": "滑动窗口",
            "slug": "sliding-window"
          }
        ],
        "hints": [
          "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
        ],
        "exampleTestcases": "\"abcabcbb\"\n\"bbbbb\"\n\"pwwkew\"",
        "sampleTestCase": "\"abcabcbb\"",
        "jsonExampleTestcases": "[\"\\\"abcabcbb\\\"\", \"\\\"bbbbb\\\"\", \"\\\"pwwkew\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "寻找两个正序数组的中位数",
        "translatedContent": "<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n\n<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,3], nums2 = [2]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]\n<strong>输出：</strong>2.50000\n<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "description": "给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.00000",
            "explanation": "合并数组 = [1,2,3] ，中位数 2",
            "raw_content": "输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2"
          },
          {
            "title": "示例 2",
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.50000",
            "explanation": "合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5",
            "raw_content": "输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5"
          }
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Binary Search",
            "nameTranslated": "二分查找",
            "slug": "binary-search"
          },
          {
            "name": "Divide and Conquer",
            "nameTranslated": "分治",
            "slug": "divide-and-conquer"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,3]\n[2]\n[1,2]\n[3,4]",
        "sampleTestCase": "[1,3]\n[2]",
        "jsonExampleTestcases": "[\"[1,3]\\n[2]\", \"[1,2]\\n[3,4]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "最长回文子串",
        "translatedContent": "<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 <span data-keyword=\"palindromic-string\">回文</span> <span data-keyword=\"substring-nonempty\">子串</span>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babad\"\n<strong>输出：</strong>\"bab\"\n<strong>解释：</strong>\"aba\" 同样是符合题意的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>\"bb\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由数字和英文字母组成</li>\n</ul>\n",
        "description": "给你一个字符串 s，找到 s 中最长的 回文 子串。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"babad\"",
            "output": "\"bab\"",
            "explanation": "\"aba\" 同样是符合题意的答案。",
            "raw_content": "输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。"
          },
          {
            "title": "示例 2",
            "input": "s = \"cbbd\"",
            "output": "\"bb\"",
            "explanation": "",
            "raw_content": "输入：s = \"cbbd\"\n输出：\"bb\""
          }
        ],
        "constraints": "1 <= s.length <= 1000\ns 仅由数字和英文字母组成",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          }
        ],
        "hints": [
          "How can we reuse a previously computed palindrome to compute a larger palindrome?",
          "If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?",
          "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
        ],
        "exampleTestcases": "\"babad\"\n\"cbbd\"",
        "sampleTestCase": "\"babad\"",
        "jsonExampleTestcases": "[\"\\\"babad\\\"\", \"\\\"cbbd\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "Z 字形变换",
        "translatedContent": "<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>\n\n<p>比如输入字符串为 <code>\"PAYPALISHIRING\"</code> 行数为 <code>3</code> 时，排列如下：</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R</pre>\n\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>\"PAHNAPLSIIGYIR\"</code>。</p>\n\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n\n<pre>\nstring convert(string s, int numRows);</pre>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PAYPALISHIRING\", numRows = 3\n<strong>输出：</strong>\"PAHNAPLSIIGYIR\"\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<strong>输入：</strong>s = \"PAYPALISHIRING\", numRows = 4\n<strong>输出：</strong>\"PINALSIGYAHRPI\"\n<strong>解释：</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"A\", numRows = 1\n<strong>输出：</strong>\"A\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 由英文字母（小写和大写）、<code>','</code> 和 <code>'.'</code> 组成</li>\n\t<li><code>1 <= numRows <= 1000</code></li>\n</ul>\n",
        "description": "将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n\nP   A   H   N\nA P L S I I G\nY   I   R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"PAYPALISHIRING\", numRows = 3",
            "output": "\"PAHNAPLSIIGYIR\"",
            "explanation": "",
            "raw_content": "输入：s = \"PAYPALISHIRING\", numRows = 3\n输出：\"PAHNAPLSIIGYIR\""
          },
          {
            "title": "示例 2",
            "input": "s = \"PAYPALISHIRING\", numRows = 4",
            "output": "\"PINALSIGYAHRPI\"",
            "explanation": "P     I    N\nA   L S  I G\nY A   H R\nP     I",
            "raw_content": "输入：s = \"PAYPALISHIRING\", numRows = 4\n输出：\"PINALSIGYAHRPI\"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I"
          },
          {
            "title": "示例 3",
            "input": "s = \"A\", numRows = 1",
            "output": "\"A\"",
            "explanation": "",
            "raw_content": "输入：s = \"A\", numRows = 1\n输出：\"A\""
          }
        ],
        "constraints": "1 <= s.length <= 1000\ns 由英文字母（小写和大写）、',' 和 '.' 组成\n1 <= numRows <= 1000",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"PAYPALISHIRING\"\n3\n\"PAYPALISHIRING\"\n4\n\"A\"\n1",
        "sampleTestCase": "\"PAYPALISHIRING\"\n3",
        "jsonExampleTestcases": "[\"\\\"PAYPALISHIRING\\\"\\n3\", \"\\\"PAYPALISHIRING\\\"\\n4\", \"\\\"A\\\"\\n1\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "整数反转",
        "translatedContent": "<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，就返回 0。</p>\n<strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 123\n<strong>输出：</strong>321\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = -123\n<strong>输出：</strong>-321\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 120\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 0\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "description": "给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。",
        "examples": [
          {
            "title": "示例 1",
            "input": "x = 123",
            "output": "321",
            "explanation": "",
            "raw_content": "输入：x = 123\n输出：321"
          },
          {
            "title": "示例 2",
            "input": "x = -123",
            "output": "-321",
            "explanation": "",
            "raw_content": "输入：x = -123\n输出：-321"
          },
          {
            "title": "示例 3",
            "input": "x = 120",
            "output": "21",
            "explanation": "",
            "raw_content": "输入：x = 120\n输出：21"
          },
          {
            "title": "示例 4",
            "input": "x = 0",
            "output": "0",
            "explanation": "",
            "raw_content": "输入：x = 0\n输出：0"
          }
        ],
        "constraints": "-231 <= x <= 231 - 1",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          }
        ],
        "hints": [],
        "exampleTestcases": "123\n-123\n120",
        "sampleTestCase": "123",
        "jsonExampleTestcases": "[\"123\", \"-123\", \"120\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "字符串转换整数 (atoi)",
        "translatedContent": "<p>请你来实现一个&nbsp;<code>myAtoi(string s)</code>&nbsp;函数，使其能将字符串转换成一个 32 位有符号整数。</p>\n\n<p>函数&nbsp;<code>myAtoi(string s)</code> 的算法如下：</p>\n\n<ol>\n\t<li><strong>空格：</strong>读入字符串并丢弃无用的前导空格（<code>\" \"</code>）</li>\n\t<li><strong>符号：</strong>检查下一个字符（假设还未到字符末尾）为&nbsp;<code>'-'</code> 还是 <code>'+'</code>。如果两者都不存在，则假定结果为正。</li>\n\t<li><strong>转换：</strong>通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。</li>\n\t<li><b>舍入：</b>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被舍入为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31&nbsp;</sup>− 1</code> 的整数应该被舍入为 <code>2<sup>31&nbsp;</sup>− 1</code> 。</li>\n</ol>\n\n<p>返回整数作为最终结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例&nbsp;1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"42\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">42</span></p>\n\n<p><strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</p>\n\n<pre>\n带下划线线的字符是所读的内容，插入符号是当前读入位置。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<u>42</u>\"（读入 \"42\"）\n           ^\n</pre>\n</div>\n\n<p><strong class=\"example\">示例&nbsp;2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \" -042\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">-42</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n第 1 步：\"<u><strong>   </strong></u>-042\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   <u>-</u>042\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   <u>-042</u>\"（读入 \"042\"，在结果中忽略前导零）\n               ^\n</pre>\n</div>\n\n<p><strong class=\"example\">示例&nbsp;3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"</span>1337c0d3<span class=\"example-io\">\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">1337</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n第 1 步：\"1337c0d3\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"1337c0d3\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"1337c0d3\"（读入 \"1337\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n</pre>\n</div>\n\n<p><strong class=\"example\">示例 4：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"0-1\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n第 1 步：\"0-1\" (当前没有读入字符，因为没有前导空格)\n         ^\n第 2 步：\"0-1\" (当前没有读入字符，因为这里不存在 '-' 或者 '+')\n         ^\n第 3 步：\"<u>0</u>-1\" (读入 \"0\"；由于下一个字符不是一个数字，所以读入停止)\n          ^\n</pre>\n</div>\n\n<p><strong class=\"example\">示例 5：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"words and 987\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>读取在第一个非数字字符“w”处停止。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>\n</ul>\n",
        "description": "请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。\n函数 myAtoi(string s) 的算法如下：\n\n空格：读入字符串并丢弃无用的前导空格（\" \"）\n符号：检查下一个字符（假设还未到字符末尾）为 '-' 还是 '+'。如果两者都不存在，则假定结果为正。\n转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。\n舍入：如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。\n\n返回整数作为最终结果。\n \n示例 1：\n\n输入：s = \"42\"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n\n带下划线线的字符是所读的内容，插入符号是当前读入位置。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^\n\n\n示例 2：\n\n输入：s = \" -042\"\n输出：-42\n解释：\n\n第 1 步：\"   -042\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -042\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -042\"（读入 \"042\"，在结果中忽略前导零）\n               ^\n\n\n示例 3：\n\n输入：s = \"1337c0d3\"\n输出：1337\n解释：\n\n第 1 步：\"1337c0d3\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"1337c0d3\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"1337c0d3\"（读入 \"1337\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n\n\n示例 4：\n\n输入：s = \"0-1\"\n输出：0\n解释：\n\n第 1 步：\"0-1\" (当前没有读入字符，因为没有前导空格)\n         ^\n第 2 步：\"0-1\" (当前没有读入字符，因为这里不存在 '-' 或者 '+')\n         ^\n第 3 步：\"0-1\" (读入 \"0\"；由于下一个字符不是一个数字，所以读入停止)\n          ^\n\n\n示例 5：\n\n输入：s = \"words and 987\"\n输出：0\n解释：\n读取在第一个非数字字符“w”处停止。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"42\"",
            "output": "42",
            "explanation": "加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n\n带下划线线的字符是所读的内容，插入符号是当前读入位置。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^",
            "raw_content": "输入：s = \"42\"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n\n带下划线线的字符是所读的内容，插入符号是当前读入位置。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^"
          },
          {
            "title": "示例 2",
            "input": "s = \" -042\"",
            "output": "-42",
            "explanation": "第 1 步：\"   -042\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -042\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -042\"（读入 \"042\"，在结果中忽略前导零）\n               ^",
            "raw_content": "输入：s = \" -042\"\n输出：-42\n解释：\n\n第 1 步：\"   -042\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -042\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -042\"（读入 \"042\"，在结果中忽略前导零）\n               ^"
          },
          {
            "title": "示例 3",
            "input": "s = \"1337c0d3\"",
            "output": "1337",
            "explanation": "第 1 步：\"1337c0d3\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"1337c0d3\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"1337c0d3\"（读入 \"1337\"；由于下一个字符不是一个数字，所以读入停止）\n             ^",
            "raw_content": "输入：s = \"1337c0d3\"\n输出：1337\n解释：\n\n第 1 步：\"1337c0d3\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"1337c0d3\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"1337c0d3\"（读入 \"1337\"；由于下一个字符不是一个数字，所以读入停止）\n             ^"
          },
          {
            "title": "示例 4",
            "input": "s = \"0-1\"",
            "output": "0",
            "explanation": "第 1 步：\"0-1\" (当前没有读入字符，因为没有前导空格)\n         ^\n第 2 步：\"0-1\" (当前没有读入字符，因为这里不存在 '-' 或者 '+')\n         ^\n第 3 步：\"0-1\" (读入 \"0\"；由于下一个字符不是一个数字，所以读入停止)\n          ^",
            "raw_content": "输入：s = \"0-1\"\n输出：0\n解释：\n\n第 1 步：\"0-1\" (当前没有读入字符，因为没有前导空格)\n         ^\n第 2 步：\"0-1\" (当前没有读入字符，因为这里不存在 '-' 或者 '+')\n         ^\n第 3 步：\"0-1\" (读入 \"0\"；由于下一个字符不是一个数字，所以读入停止)\n          ^"
          },
          {
            "title": "示例 5",
            "input": "s = \"words and 987\"",
            "output": "0",
            "explanation": "读取在第一个非数字字符“w”处停止。",
            "raw_content": "输入：s = \"words and 987\"\n输出：0\n解释：\n读取在第一个非数字字符“w”处停止。"
          }
        ],
        "constraints": "0 <= s.length <= 200\ns 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"42\"\n\"   -042\"\n\"1337c0d3\"\n\"0-1\"\n\"words and 987\"",
        "sampleTestCase": "\"42\"",
        "jsonExampleTestcases": "[\"\\\"42\\\"\", \"\\\"   -042\\\"\", \"\\\"1337c0d3\\\"\", \"\\\"0-1\\\"\", \"\\\"words and 987\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "回文数",
        "translatedContent": "<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p><span data-keyword=\"palindrome-integer\">回文数</span>是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n\n<ul>\n\t<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 121\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = -121\n<strong>输出：</strong>false\n<strong>解释：</strong>从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>从右向左读, 为 01 。因此它不是一个回文数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p>\n",
        "description": "给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。",
        "examples": [
          {
            "title": "示例 1",
            "input": "x = 121",
            "output": "true",
            "explanation": "",
            "raw_content": "输入：x = 121\n输出：true"
          },
          {
            "title": "示例 2",
            "input": "x = -121",
            "output": "false",
            "explanation": "从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。",
            "raw_content": "输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。"
          },
          {
            "title": "示例 3",
            "input": "x = 10",
            "output": "false",
            "explanation": "从右向左读, 为 01 。因此它不是一个回文数。",
            "raw_content": "输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。"
          }
        ],
        "constraints": "-231 <= x <= 231 - 1",
        "followUp": "你能不将整数转为字符串来解决这个问题吗？",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          }
        ],
        "hints": [
          "Beware of overflow when you reverse the integer."
        ],
        "exampleTestcases": "121\n-121\n10",
        "sampleTestCase": "121",
        "jsonExampleTestcases": "[\"121\", \"-121\", \"10\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "正则表达式匹配",
        "translatedContent": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>'.'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的正则表达式匹配。</p>\n\n<ul>\n\t<li><code>'.'</code> 匹配任意单个字符</li>\n\t<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>\n</ul>\n\n<p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code> 的，而不是部分字符串。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", p = \".*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>\n\t<li>保证每次出现字符&nbsp;<code>*</code> 时，前面都匹配到有效的字符</li>\n</ul>\n",
        "description": "给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"aa\", p = \"a\"",
            "output": "false",
            "explanation": "\"a\" 无法匹配 \"aa\" 整个字符串。",
            "raw_content": "输入：s = \"aa\", p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。"
          },
          {
            "title": "示例 2",
            "input": "s = \"aa\", p = \"a*\"",
            "output": "true",
            "explanation": "因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。",
            "raw_content": "输入：s = \"aa\", p = \"a*\"\n输出：true\n解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。"
          },
          {
            "title": "示例 3",
            "input": "s = \"ab\", p = \".*\"",
            "output": "true",
            "explanation": "\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。",
            "raw_content": "输入：s = \"ab\", p = \".*\"\n输出：true\n解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。"
          }
        ],
        "constraints": "1 <= s.length <= 20\n1 <= p.length <= 20\ns 只包含从 a-z 的小写字母。\np 只包含从 a-z 的小写字母，以及字符 . 和 *。\n保证每次出现字符 * 时，前面都匹配到有效的字符",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"",
        "sampleTestCase": "\"aa\"\n\"a\"",
        "jsonExampleTestcases": "[\"\\\"aa\\\"\\n\\\"a\\\"\", \"\\\"aa\\\"\\n\\\"a*\\\"\", \"\\\"ab\\\"\\n\\\".*\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "盛最多水的容器",
        "translatedContent": "<p>给定一个长度为 <code>n</code> 的整数数组&nbsp;<code>height</code>&nbsp;。有&nbsp;<code>n</code>&nbsp;条垂线，第 <code>i</code> 条线的两个端点是&nbsp;<code>(i, 0)</code>&nbsp;和&nbsp;<code>(i, height[i])</code>&nbsp;。</p>\n\n<p>找出其中的两条线，使得它们与&nbsp;<code>x</code>&nbsp;轴共同构成的容器可以容纳最多的水。</p>\n\n<p>返回容器可以储存的最大水量。</p>\n\n<p><strong>说明：</strong>你不能倾斜容器。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>[1,8,6,2,5,4,8,3,7]\n<strong>输出：</strong>49 \n<strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "description": "给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。",
        "examples": [
          {
            "title": "示例 1",
            "input": "[1,8,6,2,5,4,8,3,7]",
            "output": "49",
            "explanation": "图中垂直线代表",
            "raw_content": "输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。"
          },
          {
            "title": "示例 2",
            "input": "height = [1,1]",
            "output": "1",
            "explanation": "",
            "raw_content": "输入：height = [1,1]\n输出：1"
          }
        ],
        "constraints": "n == height.length\n2 <= n <= 105\n0 <= height[i] <= 104",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Greedy",
            "nameTranslated": "贪心",
            "slug": "greedy"
          },
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          }
        ],
        "hints": [
          "If you simulate the problem, it will be O(n^2) which is not efficient.",
          "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
          "How can you calculate the amount of water at each step?"
        ],
        "exampleTestcases": "[1,8,6,2,5,4,8,3,7]\n[1,1]",
        "sampleTestCase": "[1,8,6,2,5,4,8,3,7]",
        "jsonExampleTestcases": "[\"[1,8,6,2,5,4,8,3,7]\", \"[1,1]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "整数转罗马数字",
        "translatedContent": "<p>七个不同的符号代表罗马数字，其值如下：</p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>符号</th>\n\t\t\t<th>值</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>I</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>V</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>X</td>\n\t\t\t<td>10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>L</td>\n\t\t\t<td>50</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>C</td>\n\t\t\t<td>100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>D</td>\n\t\t\t<td>500</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>M</td>\n\t\t\t<td>1000</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：</p>\n\n<ul>\n\t<li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。</li>\n\t<li>如果该值以 4 或 9 开头，使用 <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如&nbsp;4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code>&nbsp;，9 是 10 (<code>X</code>) 减&nbsp;1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和&nbsp;900 (<code>CM</code>)。</li>\n\t<li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加&nbsp;5&nbsp;(<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加4次，请使用 <strong>减法形式</strong>。</li>\n</ul>\n\n<p>给定一个整数，将其转换为罗马数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">num = 3749</span></p>\n\n<p><strong>输出：</strong>&nbsp;<span class=\"example-io\">\"MMMDCCXLIX\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC 由于 500 (D) + 100 (C) + 100 (C)\n  40 = XL 由于 50 (L) 减 10 (X)\n   9 = IX 由于 10 (X) 减 1 (I)\n注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位\n</pre>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">num = 58</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">\"LVIII\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n50 = L\n 8 = VIII\n</pre>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">num = 1994</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">\"MCMXCIV\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<pre>\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n</pre>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n",
        "description": "七个不同的符号代表罗马数字，其值如下：\n\n\n\n符号\n值\n\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n\n罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：\n\n如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。\n如果该值以 4 或 9 开头，使用 减法形式，表示从以下符号中减去一个符号，例如 4 是 5 (V) 减 1 (I): IV ，9 是 10 (X) 减 1 (I)：IX。仅使用以下减法形式：4 (IV)，9 (IX)，40 (XL)，90 (XC)，400 (CD) 和 900 (CM)。\n只有 10 的次方（I, X, C, M）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (V)，50 (L) 或 500 (D)。如果需要将符号附加4次，请使用 减法形式。\n\n给定一个整数，将其转换为罗马数字。",
        "examples": [
          {
            "title": "示例 1",
            "input": "num = 3749",
            "output": "\"MMMDCCXLIX\"",
            "explanation": "3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC 由于 500 (D) + 100 (C) + 100 (C)\n  40 = XL 由于 50 (L) 减 10 (X)\n   9 = IX 由于 10 (X) 减 1 (I)\n注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位",
            "raw_content": "输入：num = 3749\n输出： \"MMMDCCXLIX\"\n解释：\n\n3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC 由于 500 (D) + 100 (C) + 100 (C)\n  40 = XL 由于 50 (L) 减 10 (X)\n   9 = IX 由于 10 (X) 减 1 (I)\n注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位"
          },
          {
            "title": "示例 2",
            "input": "num = 58",
            "output": "\"LVIII\"",
            "explanation": "50 = L\n 8 = VIII",
            "raw_content": "输入：num = 58\n输出：\"LVIII\"\n解释：\n\n50 = L\n 8 = VIII"
          },
          {
            "title": "示例 3",
            "input": "num = 1994",
            "output": "\"MCMXCIV\"",
            "explanation": "1000 = M\n 900 = CM\n  90 = XC\n   4 = IV",
            "raw_content": "输入：num = 1994\n输出：\"MCMXCIV\"\n解释：\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV"
          }
        ],
        "constraints": "1 <= num <= 3999",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [],
        "exampleTestcases": "3749\n58\n1994",
        "sampleTestCase": "3749",
        "jsonExampleTestcases": "[\"3749\", \"58\", \"1994\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "罗马数字转整数",
        "translatedContent": "<p>罗马数字包含以下七种字符:&nbsp;<code>I</code>，&nbsp;<code>V</code>，&nbsp;<code>X</code>，&nbsp;<code>L</code>，<code>C</code>，<code>D</code>&nbsp;和&nbsp;<code>M</code>。</p>\n\n<pre>\n<strong>字符</strong>          <strong>数值</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>例如， 罗马数字 <code>2</code> 写做&nbsp;<code>II</code>&nbsp;，即为两个并列的 1 。<code>12</code> 写做&nbsp;<code>XII</code>&nbsp;，即为&nbsp;<code>X</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。 <code>27</code> 写做&nbsp;&nbsp;<code>XXVII</code>, 即为&nbsp;<code>XX</code>&nbsp;+&nbsp;<code>V</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。</p>\n\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做&nbsp;<code>IIII</code>，而是&nbsp;<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为&nbsp;<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n\n<ul>\n\t<li><code>I</code>&nbsp;可以放在&nbsp;<code>V</code>&nbsp;(5) 和&nbsp;<code>X</code>&nbsp;(10) 的左边，来表示 4 和 9。</li>\n\t<li><code>X</code>&nbsp;可以放在&nbsp;<code>L</code>&nbsp;(50) 和&nbsp;<code>C</code>&nbsp;(100) 的左边，来表示 40 和&nbsp;90。&nbsp;</li>\n\t<li><code>C</code>&nbsp;可以放在&nbsp;<code>D</code>&nbsp;(500) 和&nbsp;<code>M</code>&nbsp;(1000) 的左边，来表示&nbsp;400 和&nbsp;900。</li>\n</ul>\n\n<p>给定一个罗马数字，将其转换成整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"III\"\n<strong>输出:</strong> 3</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"IV\"\n<strong>输出:</strong> 4</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"IX\"\n<strong>输出:</strong> 9</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"LVIII\"\n<strong>输出:</strong> 58\n<strong>解释:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"MCMXCIV\"\n<strong>输出:</strong> 1994\n<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> 仅含字符 <code>('I', 'V', 'X', 'L', 'C', 'D', 'M')</code></li>\n\t<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>\n\t<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n\t<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n\t<li>关于罗马数字的详尽书写规则，可以参考 <a href=\"https://baike.baidu.com/item/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/772296\">罗马数字 - 百度百科</a>。</li>\n</ul>\n",
        "description": "罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n \n示例 1:\n\n输入: s = \"III\"\n输出: 3\n示例 2:\n\n输入: s = \"IV\"\n输出: 4\n示例 3:\n\n输入: s = \"IX\"\n输出: 9\n示例 4:\n\n输入: s = \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n\n示例 5:\n\n输入: s = \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"III\"",
            "output": "3",
            "explanation": "",
            "raw_content": "输入: s = \"III\"\n输出: 3"
          },
          {
            "title": "示例 2",
            "input": "s = \"IV\"",
            "output": "4",
            "explanation": "",
            "raw_content": "输入: s = \"IV\"\n输出: 4"
          },
          {
            "title": "示例 3",
            "input": "s = \"IX\"",
            "output": "9",
            "explanation": "",
            "raw_content": "输入: s = \"IX\"\n输出: 9"
          },
          {
            "title": "示例 4",
            "input": "s = \"LVIII\"",
            "output": "58",
            "explanation": "L = 50, V= 5, III = 3.",
            "raw_content": "输入: s = \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3."
          },
          {
            "title": "示例 5",
            "input": "s = \"MCMXCIV\"",
            "output": "1994",
            "explanation": "M = 1000, CM = 900, XC = 90, IV = 4.",
            "raw_content": "输入: s = \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4."
          }
        ],
        "constraints": "1 <= s.length <= 15\ns 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')\n题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\nIL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n关于罗马数字的详尽书写规则，可以参考 罗马数字 - 百度百科。",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [
          "Problem is simpler to solve by working the string from back to front and using a map."
        ],
        "exampleTestcases": "\"III\"\n\"LVIII\"\n\"MCMXCIV\"",
        "sampleTestCase": "\"III\"",
        "jsonExampleTestcases": "[\"\\\"III\\\"\", \"\\\"LVIII\\\"\", \"\\\"MCMXCIV\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "最长公共前缀",
        "translatedContent": "<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n\n<p>如果不存在公共前缀，返回空字符串&nbsp;<code>\"\"</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"flower\",\"flow\",\"flight\"]\n<strong>输出：</strong>\"fl\"\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"dog\",\"racecar\",\"car\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>输入不存在公共前缀。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code>&nbsp;如果非空，则仅由小写英文字母组成</li>\n</ul>\n",
        "description": "编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \"\"。",
        "examples": [
          {
            "title": "示例 1",
            "input": "strs = [\"flower\",\"flow\",\"flight\"]",
            "output": "\"fl\"",
            "explanation": "",
            "raw_content": "输入：strs = [\"flower\",\"flow\",\"flight\"]\n输出：\"fl\""
          },
          {
            "title": "示例 2",
            "input": "strs = [\"dog\",\"racecar\",\"car\"]",
            "output": "\"\"",
            "explanation": "",
            "raw_content": "输入：strs = [\"dog\",\"racecar\",\"car\"]\n输出：\"\"\n解释：输入不存在公共前缀。"
          }
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] 如果非空，则仅由小写英文字母组成",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Trie",
            "nameTranslated": "字典树",
            "slug": "trie"
          },
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [],
        "exampleTestcases": "[\"flower\",\"flow\",\"flight\"]\n[\"dog\",\"racecar\",\"car\"]",
        "sampleTestCase": "[\"flower\",\"flow\",\"flight\"]",
        "jsonExampleTestcases": "[\"[\\\"flower\\\",\\\"flow\\\",\\\"flight\\\"]\", \"[\\\"dog\\\",\\\"racecar\\\",\\\"car\\\"]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "三数之和",
        "translatedContent": "<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n<strong>解释：</strong>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[]\n<strong>解释：</strong>唯一可能的三元组和不为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[[0,0,0]]\n<strong>解释：</strong>唯一可能的三元组和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "description": "给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [-1,0,1,2,-1,-4]",
            "output": "[[-1,-1,2],[-1,0,1]]",
            "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，",
            "raw_content": "输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。"
          },
          {
            "title": "示例 2",
            "input": "nums = [0,1,1]",
            "output": "[]",
            "explanation": "唯一可能的三元组和不为 0 。",
            "raw_content": "输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。"
          },
          {
            "title": "示例 3",
            "input": "nums = [0,0,0]",
            "output": "[[0,0,0]]",
            "explanation": "唯一可能的三元组和为 0 。",
            "raw_content": "输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。"
          }
        ],
        "constraints": "3 <= nums.length <= 3000\n-105 <= nums[i] <= 105",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "Sorting",
            "nameTranslated": "排序",
            "slug": "sorting"
          }
        ],
        "hints": [
          "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
          "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "exampleTestcases": "[-1,0,1,2,-1,-4]\n[0,1,1]\n[0,0,0]",
        "sampleTestCase": "[-1,0,1,2,-1,-4]",
        "jsonExampleTestcases": "[\"[-1,0,1,2,-1,-4]\", \"[0,1,1]\", \"[0,0,0]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "最接近的三数之和",
        "translatedContent": "<p>给你一个长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。请你从 <code>nums</code><em> </em>中选出三个整数，使它们的和与&nbsp;<code>target</code>&nbsp;最接近。</p>\n\n<p>返回这三个数的和。</p>\n\n<p>假定每组输入只存在恰好一个解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2,1,-4], target = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0], target = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>与 target 最接近的和是 0（0 + 0 + 0 = 0）。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "description": "给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n返回这三个数的和。\n假定每组输入只存在恰好一个解。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [-1,2,1,-4], target = 1",
            "output": "2",
            "explanation": "与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。",
            "raw_content": "输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。"
          },
          {
            "title": "示例 2",
            "input": "nums = [0,0,0], target = 1",
            "output": "0",
            "explanation": "与 target 最接近的和是 0（0 + 0 + 0 = 0）。",
            "raw_content": "输入：nums = [0,0,0], target = 1\n输出：0\n解释：与 target 最接近的和是 0（0 + 0 + 0 = 0）。"
          }
        ],
        "constraints": "3 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\n-104 <= target <= 104",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "Sorting",
            "nameTranslated": "排序",
            "slug": "sorting"
          }
        ],
        "hints": [],
        "exampleTestcases": "[-1,2,1,-4]\n1\n[0,0,0]\n1",
        "sampleTestCase": "[-1,2,1,-4]\n1",
        "jsonExampleTestcases": "[\"[-1,2,1,-4]\\n1\", \"[0,0,0]\\n1\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "电话号码的字母组合",
        "translatedContent": "<p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n\n<p><img src=\"https://pic.leetcode.cn/1752723054-mfIHZs-image.png\" style=\"width: 200px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = \"23\"\n<strong>输出：</strong>[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = \"2\"\n<strong>输出：</strong>[\"a\",\"b\",\"c\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li>\n</ul>\n",
        "description": "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。",
        "examples": [
          {
            "title": "示例 1",
            "input": "digits = \"23\"",
            "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
            "explanation": "",
            "raw_content": "输入：digits = \"23\"\n输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
          },
          {
            "title": "示例 2",
            "input": "digits = \"2\"",
            "output": "[\"a\",\"b\",\"c\"]",
            "explanation": "",
            "raw_content": "输入：digits = \"2\"\n输出：[\"a\",\"b\",\"c\"]"
          }
        ],
        "constraints": "1 <= digits.length <= 4\ndigits[i] 是范围 ['2', '9'] 的一个数字。",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"23\"\n\"2\"",
        "sampleTestCase": "\"23\"",
        "jsonExampleTestcases": "[\"\\\"23\\\"\", \"\\\"2\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "四数之和",
        "translatedContent": "<p>给你一个由 <code>n</code> 个整数组成的数组&nbsp;<code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组&nbsp;<code>[nums[a], nums[b], nums[c], nums[d]]</code>&nbsp;（若两个四元组元素一一对应，则认为两个四元组重复）：</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,-1,0,-2,2], target = 0\n<strong>输出：</strong>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2], target = 8\n<strong>输出：</strong>[[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "description": "给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 <= a, b, c, d < n\na、b、c 和 d 互不相同\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n你可以按 任意顺序 返回答案 。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,0,-1,0,-2,2], target = 0",
            "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
            "explanation": "",
            "raw_content": "输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]"
          },
          {
            "title": "示例 2",
            "input": "nums = [2,2,2,2,2], target = 8",
            "output": "[[2,2,2,2]]",
            "explanation": "",
            "raw_content": "输入：nums = [2,2,2,2,2], target = 8\n输出：[[2,2,2,2]]"
          }
        ],
        "constraints": "1 <= nums.length <= 200\n-109 <= nums[i] <= 109\n-109 <= target <= 109",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "Sorting",
            "nameTranslated": "排序",
            "slug": "sorting"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,0,-1,0,-2,2]\n0\n[2,2,2,2,2]\n8",
        "sampleTestCase": "[1,0,-1,0,-2,2]\n0",
        "jsonExampleTestcases": "[\"[1,0,-1,0,-2,2]\\n0\", \"[2,2,2,2,2]\\n8\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "删除链表的倒数第 N 个结点",
        "translatedContent": "<p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n",
        "description": "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。",
        "examples": [
          {
            "title": "示例 1",
            "input": "head = [1,2,3,4,5], n = 2",
            "output": "[1,2,3,5]",
            "explanation": "",
            "raw_content": "输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]"
          },
          {
            "title": "示例 2",
            "input": "head = [1], n = 1",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入：head = [1], n = 1\n输出：[]"
          },
          {
            "title": "示例 3",
            "input": "head = [1,2], n = 1",
            "output": "[1]",
            "explanation": "",
            "raw_content": "输入：head = [1,2], n = 1\n输出：[1]"
          }
        ],
        "constraints": "链表中结点的数目为 sz\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz",
        "followUp": "你能尝试使用一趟扫描实现吗？",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          }
        ],
        "hints": [
          "Maintain two pointers and update one with a delay of n steps."
        ],
        "exampleTestcases": "[1,2,3,4,5]\n2\n[1]\n1\n[1,2]\n1",
        "sampleTestCase": "[1,2,3,4,5]\n2",
        "jsonExampleTestcases": "[\"[1,2,3,4,5]\\n2\", \"[1]\\n1\", \"[1,2]\\n1\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "有效的括号",
        "translatedContent": "<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>&nbsp;的字符串 <code>s</code> ，判断字符串是否有效。</p>\n\n<p>有效字符串需满足：</p>\n\n<ol>\n\t<li>左括号必须用相同类型的右括号闭合。</li>\n\t<li>左括号必须以正确的顺序闭合。</li>\n\t<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"()\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"()[]{}\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"(]\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>false</span></p>\n</div>\n\n<p><strong class=\"example\">示例 4：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"([])\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n</div>\n\n<p><strong class=\"example\">示例 5：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"([)]\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>false</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li>\n</ul>\n",
        "description": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"()\"",
            "output": "true",
            "explanation": "",
            "raw_content": "输入：s = \"()\"\n输出：true"
          },
          {
            "title": "示例 2",
            "input": "s = \"()[]{}\"",
            "output": "true",
            "explanation": "",
            "raw_content": "输入：s = \"()[]{}\"\n输出：true"
          },
          {
            "title": "示例 3",
            "input": "s = \"(]\"",
            "output": "false",
            "explanation": "",
            "raw_content": "输入：s = \"(]\"\n输出：false"
          },
          {
            "title": "示例 4",
            "input": "s = \"([])\"",
            "output": "true",
            "explanation": "",
            "raw_content": "输入：s = \"([])\"\n输出：true"
          },
          {
            "title": "示例 5",
            "input": "s = \"([)]\"",
            "output": "false",
            "explanation": "",
            "raw_content": "输入：s = \"([)]\"\n输出：false"
          }
        ],
        "constraints": "1 <= s.length <= 104\ns 仅由括号 '()[]{}' 组成",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Stack",
            "nameTranslated": "栈",
            "slug": "stack"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [
          "Use a stack of characters.",
          "When you encounter an opening bracket, push it to the top of the stack.",
          "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
        ],
        "exampleTestcases": "\"()\"\n\"()[]{}\"\n\"(]\"\n\"([])\"\n\"([)]\"",
        "sampleTestCase": "\"()\"",
        "jsonExampleTestcases": "[\"\\\"()\\\"\", \"\\\"()[]{}\\\"\", \"\\\"(]\\\"\", \"\\\"([])\\\"\", \"\\\"([)]\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "合并两个有序链表",
        "translatedContent": "<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]\n<strong>输出：</strong>[1,1,2,3,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n",
        "description": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。",
        "examples": [
          {
            "title": "示例 1",
            "input": "l1 = [1,2,4], l2 = [1,3,4]",
            "output": "[1,1,2,3,4,4]",
            "explanation": "",
            "raw_content": "输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]"
          },
          {
            "title": "示例 2",
            "input": "l1 = [], l2 = []",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入：l1 = [], l2 = []\n输出：[]"
          },
          {
            "title": "示例 3",
            "input": "l1 = [], l2 = [0]",
            "output": "[0]",
            "explanation": "",
            "raw_content": "输入：l1 = [], l2 = [0]\n输出：[0]"
          }
        ],
        "constraints": "两个链表的节点数目范围是 [0, 50]\n-100 <= Node.val <= 100\nl1 和 l2 均按 非递减顺序 排列",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,2,4]\n[1,3,4]\n[]\n[]\n[]\n[0]",
        "sampleTestCase": "[1,2,4]\n[1,3,4]",
        "jsonExampleTestcases": "[\"[1,2,4]\\n[1,3,4]\", \"[]\\n[]\", \"[]\\n[0]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "括号生成",
        "translatedContent": "<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[\"()\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "description": "数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。",
        "examples": [
          {
            "title": "示例 1",
            "input": "n = 3",
            "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
            "explanation": "",
            "raw_content": "输入：n = 3\n输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
          },
          {
            "title": "示例 2",
            "input": "n = 1",
            "output": "[\"()\"]",
            "explanation": "",
            "raw_content": "输入：n = 1\n输出：[\"()\"]"
          }
        ],
        "constraints": "1 <= n <= 8",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          }
        ],
        "hints": [],
        "exampleTestcases": "3\n1",
        "sampleTestCase": "3",
        "jsonExampleTestcases": "[\"3\", \"1\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "合并 K 个升序链表",
        "translatedContent": "<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n",
        "description": "给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。",
        "examples": [
          {
            "title": "示例 1",
            "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
            "output": "[1,1,2,3,4,4,5,6]",
            "explanation": "链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6",
            "raw_content": "输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6"
          },
          {
            "title": "示例 2",
            "input": "lists = []",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入：lists = []\n输出：[]"
          },
          {
            "title": "示例 3",
            "input": "lists = [[]]",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入：lists = [[]]\n输出：[]"
          }
        ],
        "constraints": "k == lists.length\n0 <= k <= 10^4\n0 <= lists[i].length <= 500\n-10^4 <= lists[i][j] <= 10^4\nlists[i] 按 升序 排列\nlists[i].length 的总和不超过 10^4",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          },
          {
            "name": "Divide and Conquer",
            "nameTranslated": "分治",
            "slug": "divide-and-conquer"
          },
          {
            "name": "Heap (Priority Queue)",
            "nameTranslated": "堆（优先队列）",
            "slug": "heap-priority-queue"
          },
          {
            "name": "Merge Sort",
            "nameTranslated": "归并排序",
            "slug": "merge-sort"
          }
        ],
        "hints": [],
        "exampleTestcases": "[[1,4,5],[1,3,4],[2,6]]\n[]\n[[]]",
        "sampleTestCase": "[[1,4,5],[1,3,4],[2,6]]",
        "jsonExampleTestcases": "[\"[[1,4,5],[1,3,4],[2,6]]\", \"[]\", \"[[]]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "两两交换链表中的节点",
        "translatedContent": "<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "description": "给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。",
        "examples": [
          {
            "title": "示例 1",
            "input": "head = [1,2,3,4]",
            "output": "[2,1,4,3]",
            "explanation": "",
            "raw_content": "输入：head = [1,2,3,4]\n输出：[2,1,4,3]"
          },
          {
            "title": "示例 2",
            "input": "head = []",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入：head = []\n输出：[]"
          },
          {
            "title": "示例 3",
            "input": "head = [1]",
            "output": "[1]",
            "explanation": "",
            "raw_content": "输入：head = [1]\n输出：[1]"
          }
        ],
        "constraints": "链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,2,3,4]\n[]\n[1]\n[1,2,3]",
        "sampleTestCase": "[1,2,3,4]",
        "jsonExampleTestcases": "[\"[1,2,3,4]\", \"[]\", \"[1]\", \"[1,2,3]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "K 个一组翻转链表",
        "translatedContent": "<p>给你链表的头节点 <code>head</code> ，每&nbsp;<code>k</code><em>&nbsp;</em>个节点一组进行翻转，请你返回修改后的链表。</p>\n\n<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是&nbsp;<code>k</code><em>&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[2,1,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 3\n<strong>输出：</strong>[3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li>链表中的节点数目为 <code>n</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>\n\n<ul>\n</ul>\n",
        "description": "给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。",
        "examples": [
          {
            "title": "示例 1",
            "input": "head = [1,2,3,4,5], k = 2",
            "output": "[2,1,4,3,5]",
            "explanation": "",
            "raw_content": "输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]"
          },
          {
            "title": "示例 2",
            "input": "head = [1,2,3,4,5], k = 3",
            "output": "[3,2,1,4,5]",
            "explanation": "",
            "raw_content": "输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]"
          }
        ],
        "constraints": "链表中的节点数目为 n\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000",
        "followUp": "你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "Linked List",
            "nameTranslated": "链表",
            "slug": "linked-list"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,2,3,4,5]\n2\n[1,2,3,4,5]\n3",
        "sampleTestCase": "[1,2,3,4,5]\n2",
        "jsonExampleTestcases": "[\"[1,2,3,4,5]\\n2\", \"[1,2,3,4,5]\\n3\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "删除有序数组中的重复项",
        "translatedContent": "<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>\n\n<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 <code>k</code>。</p>\n\n<p><code>nums</code> 的前 <code>k</code> 个元素应包含 <strong>排序后</strong> 的唯一数字。下标&nbsp;<code>k - 1</code> 之后的剩余元素可以忽略。</p>\n\n<p><strong>判题标准:</strong></p>\n\n<p>系统会用下面的代码来测试你的题解:</p>\n\n<pre>\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}</pre>\n\n<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>2, nums = [1,2,_]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>2</code></strong> ，并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2 </code></strong><code>。</code>不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]\n<strong>输出：</strong>5, nums = [0,1,2,3,4,_,_,_,_,_]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong> ， 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 。不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<font size=\"1\">0</font>&nbsp;&lt;= nums[i] &lt;= 10<font size=\"1\">0</font></code></li>\n\t<li><code>nums</code> 已按 <strong>非递减</strong>&nbsp;顺序排列。</li>\n</ul>\n",
        "description": "给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。\nnums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。\n判题标准:\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n如果所有断言都通过，那么您的题解将被 通过。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,1,2]",
            "output": "2, nums = [1,2,_]",
            "explanation": "函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。",
            "raw_content": "输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。"
          },
          {
            "title": "示例 2",
            "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
            "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
            "explanation": "函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。",
            "raw_content": "输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4,_,_,_,_,_]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。"
          }
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums 已按 非递减 顺序排列。",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          }
        ],
        "hints": [
          "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/>",
          "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
          "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
        ],
        "exampleTestcases": "[1,1,2]\n[0,0,1,1,1,2,2,3,3,4]",
        "sampleTestCase": "[1,1,2]",
        "jsonExampleTestcases": "[\"[1,1,2]\", \"[0,0,1,1,1,2,2,3,3,4]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "移除元素",
        "translatedContent": "<p>给你一个数组 <code>nums</code><em>&nbsp;</em>和一个值 <code>val</code>，你需要 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong> 移除所有数值等于&nbsp;<code>val</code><em>&nbsp;</em>的元素。元素的顺序可能发生改变。然后返回&nbsp;<code>nums</code>&nbsp;中与&nbsp;<code>val</code>&nbsp;不同的元素的数量。</p>\n\n<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>\n\n<ul>\n\t<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>\n\t<li>返回 <code>k</code>。</li>\n</ul>\n\n<p><strong>用户评测：</strong></p>\n\n<p>评测机将使用以下代码测试您的解决方案：</p>\n\n<pre>\nint[] nums = [...]; // 输入数组\nint val = ...; // 要移除的值\nint[] expectedNums = [...]; // 长度正确的预期答案。\n                            // 它以不等于 val 的值排序。\n\nint k = removeElement(nums, val); // 调用你的实现\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // 排序 nums 的前 k 个元素\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}</pre>\n\n<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,2,3], val = 3\n<strong>输出：</strong>2, nums = [2,2,_,_]\n<strong>解释：</strong>你的函数函数应该返回 k = 2, 并且 nums<em> </em>中的前两个元素均为 2。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>输出：</strong>5, nums = [0,1,4,0,3,_,_,_]\n<strong>解释：</strong>你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。\n注意这五个元素可以任意顺序返回。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n",
        "description": "给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\n假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：\n\n更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。\n返回 k。\n\n用户评测：\n评测机将使用以下代码测试您的解决方案：\n\nint[] nums = [...]; // 输入数组\nint val = ...; // 要移除的值\nint[] expectedNums = [...]; // 长度正确的预期答案。\n                            // 它以不等于 val 的值排序。\n\nint k = removeElement(nums, val); // 调用你的实现\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // 排序 nums 的前 k 个元素\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n如果所有的断言都通过，你的解决方案将会 通过。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [3,2,2,3], val = 3",
            "output": "2, nums = [2,2,_,_]",
            "explanation": "你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。",
            "raw_content": "输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2,_,_]\n解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。"
          },
          {
            "title": "示例 2",
            "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
            "output": "5, nums = [0,1,4,0,3,_,_,_]",
            "explanation": "你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。\n注意这五个元素可以任意顺序返回。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。",
            "raw_content": "输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3,_,_,_]\n解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。\n注意这五个元素可以任意顺序返回。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。"
          }
        ],
        "constraints": "0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          }
        ],
        "hints": [
          "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per se, right?",
          "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
          "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
        ],
        "exampleTestcases": "[3,2,2,3]\n3\n[0,1,2,2,3,0,4,2]\n2",
        "sampleTestCase": "[3,2,2,3]\n3",
        "jsonExampleTestcases": "[\"[3,2,2,3]\\n3\", \"[0,1,2,2,3,0,4,2]\\n2\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "找出字符串中第一个匹配项的下标",
        "translatedContent": "<p>给你两个字符串&nbsp;<code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果&nbsp;<code>needle</code> 不是 <code>haystack</code> 的一部分，则返回&nbsp; <code>-1</code><strong> </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>haystack = \"sadbutsad\", needle = \"sad\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"sad\" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>haystack = \"leetcode\", needle = \"leeto\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>\n</ul>\n",
        "description": "给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。",
        "examples": [
          {
            "title": "示例 1",
            "input": "haystack = \"sadbutsad\", needle = \"sad\"",
            "output": "0",
            "explanation": "\"sad\" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。",
            "raw_content": "输入：haystack = \"sadbutsad\", needle = \"sad\"\n输出：0\n解释：\"sad\" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。"
          },
          {
            "title": "示例 2",
            "input": "haystack = \"leetcode\", needle = \"leeto\"",
            "output": "-1",
            "explanation": "\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。",
            "raw_content": "输入：haystack = \"leetcode\", needle = \"leeto\"\n输出：-1\n解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。"
          }
        ],
        "constraints": "1 <= haystack.length, needle.length <= 104\nhaystack 和 needle 仅由小写英文字符组成",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "String Matching",
            "nameTranslated": "字符串匹配",
            "slug": "string-matching"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"sadbutsad\"\n\"sad\"\n\"leetcode\"\n\"leeto\"",
        "sampleTestCase": "\"sadbutsad\"\n\"sad\"",
        "jsonExampleTestcases": "[\"\\\"sadbutsad\\\"\\n\\\"sad\\\"\", \"\\\"leetcode\\\"\\n\\\"leeto\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "两数相除",
        "translatedContent": "<p>给你两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。</p>\n\n<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。</p>\n\n<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的 <strong>商</strong> 。</p>\n\n<p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>2<sup>31&nbsp;</sup>− 1</code> ，则返回 <code>2<sup>31&nbsp;</sup>− 1</code> ；如果商 <strong>严格小于</strong> <code>-2<sup>31</sup></code> ，则返回 <code>-2<sup>31</sup></code><sup> </sup>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> dividend = 10, divisor = 3\n<strong>输出:</strong> 3\n<strong>解释: </strong>10/3 = 3.33333.. ，向零截断后得到 3 。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> dividend = 7, divisor = -3\n<strong>输出:</strong> -2\n<strong>解释:</strong> 7/-3 = -2.33333.. ，向零截断后得到 -2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n",
        "description": "给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。\n整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。\n返回被除数 dividend 除以除数 divisor 得到的 商 。\n注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。\n \n示例 1:\n\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = 3.33333.. ，向零截断后得到 3 。\n示例 2:\n\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = -2.33333.. ，向零截断后得到 -2 。",
        "examples": [
          {
            "title": "示例 1",
            "input": "dividend = 10, divisor = 3",
            "output": "3",
            "explanation": "10/3 = 3.33333.. ，向零截断后得到 3 。",
            "raw_content": "输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = 3.33333.. ，向零截断后得到 3 。"
          },
          {
            "title": "示例 2",
            "input": "dividend = 7, divisor = -3",
            "output": "-2",
            "explanation": "7/-3 = -2.33333.. ，向零截断后得到 -2 。",
            "raw_content": "输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = -2.33333.. ，向零截断后得到 -2 。"
          }
        ],
        "constraints": "-231 <= dividend, divisor <= 231 - 1\ndivisor != 0",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Bit Manipulation",
            "nameTranslated": "位运算",
            "slug": "bit-manipulation"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          }
        ],
        "hints": [],
        "exampleTestcases": "10\n3\n7\n-3",
        "sampleTestCase": "10\n3",
        "jsonExampleTestcases": "[\"10\\n3\", \"7\\n-3\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "串联所有单词的子串",
        "translatedContent": "<p>给定一个字符串&nbsp;<code>s</code><strong>&nbsp;</strong>和一个字符串数组&nbsp;<code>words</code><strong>。</strong>&nbsp;<code>words</code>&nbsp;中所有字符串 <strong>长度相同</strong>。</p>\n\n<p>&nbsp;<code>s</code><strong>&nbsp;</strong>中的 <strong>串联子串</strong> 是指一个包含&nbsp;&nbsp;<code>words</code>&nbsp;中所有字符串以任意顺序排列连接起来的子串。</p>\n\n<ul>\n\t<li>例如，如果&nbsp;<code>words = [\"ab\",\"cd\",\"ef\"]</code>， 那么&nbsp;<code>\"abcdef\"</code>，&nbsp;<code>\"abefcd\"</code>，<code>\"cdabef\"</code>，&nbsp;<code>\"cdefab\"</code>，<code>\"efabcd\"</code>， 和&nbsp;<code>\"efcdab\"</code> 都是串联子串。&nbsp;<code>\"acdbef\"</code> 不是串联子串，因为他不是任何&nbsp;<code>words</code>&nbsp;排列的连接。</li>\n</ul>\n\n<p>返回所有串联子串在&nbsp;<code>s</code><strong>&nbsp;</strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n<code><strong>输出：</strong>[]</code>\n<strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n<strong>输出：</strong>[6,9,12]\n<strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code>&nbsp;和&nbsp;<code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "description": "给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。\n\n返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
            "output": "[0,9]",
            "explanation": "因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。",
            "raw_content": "输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。"
          },
          {
            "title": "示例 2",
            "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
            "output": "[]",
            "explanation": "因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。",
            "raw_content": "输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。"
          },
          {
            "title": "示例 3",
            "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
            "output": "[6,9,12]",
            "explanation": "因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。",
            "raw_content": "输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。"
          }
        ],
        "constraints": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] 和 s 由小写英文字母组成",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Sliding Window",
            "nameTranslated": "滑动窗口",
            "slug": "sliding-window"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"barfoothefoobarman\"\n[\"foo\",\"bar\"]\n\"wordgoodgoodgoodbestword\"\n[\"word\",\"good\",\"best\",\"word\"]\n\"barfoofoobarthefoobarman\"\n[\"bar\",\"foo\",\"the\"]",
        "sampleTestCase": "\"barfoothefoobarman\"\n[\"foo\",\"bar\"]",
        "jsonExampleTestcases": "[\"\\\"barfoothefoobarman\\\"\\n[\\\"foo\\\",\\\"bar\\\"]\", \"\\\"wordgoodgoodgoodbestword\\\"\\n[\\\"word\\\",\\\"good\\\",\\\"best\\\",\\\"word\\\"]\", \"\\\"barfoofoobarthefoobarman\\\"\\n[\\\"bar\\\",\\\"foo\\\",\\\"the\\\"]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "下一个排列",
        "translatedContent": "<p>整数数组的一个 <strong>排列</strong>&nbsp; 就是将其所有成员以序列或线性顺序排列。</p>\n\n<ul>\n\t<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n\n<ul>\n\t<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n\t<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n\t<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n\n<p>必须<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,5]\n<strong>输出：</strong>[1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "description": "整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。\n\n例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。\n\n整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。\n类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。\n而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。\n\n给你一个整数数组 nums ，找出 nums 的下一个排列。\n必须 原地 修改，只允许使用额外常数空间。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,2,3]",
            "output": "[1,3,2]",
            "explanation": "",
            "raw_content": "输入：nums = [1,2,3]\n输出：[1,3,2]"
          },
          {
            "title": "示例 2",
            "input": "nums = [3,2,1]",
            "output": "[1,2,3]",
            "explanation": "",
            "raw_content": "输入：nums = [3,2,1]\n输出：[1,2,3]"
          },
          {
            "title": "示例 3",
            "input": "nums = [1,1,5]",
            "output": "[1,5,1]",
            "explanation": "",
            "raw_content": "输入：nums = [1,1,5]\n输出：[1,5,1]"
          }
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,2,3]\n[3,2,1]\n[1,1,5]",
        "sampleTestCase": "[1,2,3]",
        "jsonExampleTestcases": "[\"[1,2,3]\", \"[3,2,1]\", \"[1,1,5]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "最长有效括号",
        "translatedContent": "<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号 <span data-keyword=\"substring\">子串</span> 的长度。</p>\n\n<p>左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如&nbsp;<code>\"(()())\"</code>。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最长有效括号子串是 \"()\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \")()())\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长有效括号子串是 \"()()\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"\"\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>\n</ul>\n</div>\n</div>\n",
        "description": "给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。\n左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 \"(()())\"。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"(()\"",
            "output": "2",
            "explanation": "最长有效括号子串是 \"()\"",
            "raw_content": "输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\""
          },
          {
            "title": "示例 2",
            "input": "s = \")()())\"",
            "output": "4",
            "explanation": "最长有效括号子串是 \"()()\"",
            "raw_content": "输入：s = \")()())\"\n输出：4\n解释：最长有效括号子串是 \"()()\""
          },
          {
            "title": "示例 3",
            "input": "s = \"\"",
            "output": "0",
            "explanation": "",
            "raw_content": "输入：s = \"\"\n输出：0"
          }
        ],
        "constraints": "0 <= s.length <= 3 * 104\ns[i] 为 '(' 或 ')'",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Stack",
            "nameTranslated": "栈",
            "slug": "stack"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"(()\"\n\")()())\"\n\"\"",
        "sampleTestCase": "\"(()\"",
        "jsonExampleTestcases": "[\"\\\"(()\\\"\", \"\\\")()())\\\"\", \"\\\"\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "搜索旋转排序数组",
        "translatedContent": "<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标&nbsp;<code>3</code>&nbsp;上向左旋转后可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 0\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "description": "整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [4,5,6,7,0,1,2], target = 0",
            "output": "4",
            "explanation": "",
            "raw_content": "输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4"
          },
          {
            "title": "示例 2",
            "input": "nums = [4,5,6,7,0,1,2], target = 3",
            "output": "-1",
            "explanation": "",
            "raw_content": "输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1"
          },
          {
            "title": "示例 3",
            "input": "nums = [1], target = 0",
            "output": "-1",
            "explanation": "",
            "raw_content": "输入：nums = [1], target = 0\n输出：-1"
          }
        ],
        "constraints": "1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 <= target <= 104",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Binary Search",
            "nameTranslated": "二分查找",
            "slug": "binary-search"
          }
        ],
        "hints": [],
        "exampleTestcases": "[4,5,6,7,0,1,2]\n0\n[4,5,6,7,0,1,2]\n3\n[1]\n0",
        "sampleTestCase": "[4,5,6,7,0,1,2]\n0",
        "jsonExampleTestcases": "[\"[4,5,6,7,0,1,2]\\n0\", \"[4,5,6,7,0,1,2]\\n3\", \"[1]\\n0\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "在排序数组中查找元素的第一个和最后一个位置",
        "translatedContent": "<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n\n<p>如果数组中不存在目标值 <code>target</code>，返回&nbsp;<code>[-1, -1]</code>。</p>\n\n<p>你必须设计并实现时间复杂度为&nbsp;<code>O(log n)</code>&nbsp;的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出：</strong>[3,4]</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [], target = 0\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code>&nbsp;是一个非递减数组</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "description": "给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [5,7,7,8,8,10], target = 8",
            "output": "[3,4]",
            "explanation": "",
            "raw_content": "输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]"
          },
          {
            "title": "示例 2",
            "input": "nums = [5,7,7,8,8,10], target = 6",
            "output": "[-1,-1]",
            "explanation": "",
            "raw_content": "输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]"
          },
          {
            "title": "示例 3",
            "input": "nums = [], target = 0",
            "output": "[-1,-1]",
            "explanation": "",
            "raw_content": "输入：nums = [], target = 0\n输出：[-1,-1]"
          }
        ],
        "constraints": "0 <= nums.length <= 105\n-109 <= nums[i] <= 109\nnums 是一个非递减数组\n-109 <= target <= 109",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Binary Search",
            "nameTranslated": "二分查找",
            "slug": "binary-search"
          }
        ],
        "hints": [],
        "exampleTestcases": "[5,7,7,8,8,10]\n8\n[5,7,7,8,8,10]\n6\n[]\n0",
        "sampleTestCase": "[5,7,7,8,8,10]\n8",
        "jsonExampleTestcases": "[\"[5,7,7,8,8,10]\\n8\", \"[5,7,7,8,8,10]\\n6\", \"[]\\n0\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "搜索插入位置",
        "translatedContent": "<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 7\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 为&nbsp;<strong>无重复元素&nbsp;</strong>的&nbsp;<strong>升序&nbsp;</strong>排列数组</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "description": "给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,3,5,6], target = 5",
            "output": "2",
            "explanation": "",
            "raw_content": "输入: nums = [1,3,5,6], target = 5\n输出: 2"
          },
          {
            "title": "示例 2",
            "input": "nums = [1,3,5,6], target = 2",
            "output": "1",
            "explanation": "",
            "raw_content": "输入: nums = [1,3,5,6], target = 2\n输出: 1"
          },
          {
            "title": "示例 3",
            "input": "nums = [1,3,5,6], target = 7",
            "output": "4",
            "explanation": "",
            "raw_content": "输入: nums = [1,3,5,6], target = 7\n输出: 4"
          }
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums 为 无重复元素 的 升序 排列数组\n-104 <= target <= 104",
        "followUp": "",
        "difficulty": "Easy",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Binary Search",
            "nameTranslated": "二分查找",
            "slug": "binary-search"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,3,5,6]\n5\n[1,3,5,6]\n2\n[1,3,5,6]\n7",
        "sampleTestCase": "[1,3,5,6]\n5",
        "jsonExampleTestcases": "[\"[1,3,5,6]\\n5\", \"[1,3,5,6]\\n2\", \"[1,3,5,6]\\n7\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "有效的数独",
        "translatedContent": "<p>请你判断一个&nbsp;<code>9 x 9</code> 的数独是否有效。只需要<strong> 根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一个有效的数独（部分已被填充）不一定是可解的。</li>\n\t<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>\n\t<li>空白格用&nbsp;<code>'.'</code>&nbsp;表示。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>输入：</strong>board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>false\n<strong>解释：</strong>除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字（<code>1-9</code>）或者 <code>'.'</code></li>\n</ul>\n",
        "description": "请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n \n注意：\n\n一个有效的数独（部分已被填充）不一定是可解的。\n只需要根据以上规则，验证已经填入的数字是否有效即可。\n空白格用 '.' 表示。",
        "examples": [
          {
            "title": "示例 1",
            "input": "board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "true",
            "explanation": "",
            "raw_content": "输入：board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n输出：true"
          },
          {
            "title": "示例 2",
            "input": "board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "false",
            "explanation": "除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与",
            "raw_content": "输入：board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n输出：false\n解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与"
          },
          {
            "title": "示例 3",
            "input": "",
            "output": "",
            "explanation": "",
            "raw_content": "相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。"
          }
        ],
        "constraints": "board.length == 9\nboard[i].length == 9\nboard[i][j] 是一位数字（1-9）或者 '.'",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "Matrix",
            "nameTranslated": "矩阵",
            "slug": "matrix"
          }
        ],
        "hints": [],
        "exampleTestcases": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "sampleTestCase": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "jsonExampleTestcases": "[\"[[\\\"5\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\"6\\\",\\\".\\\",\\\".\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\".\\\",\\\"9\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\"],[\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"3\\\"],[\\\"4\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"1\\\"],[\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\"],[\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\"8\\\",\\\".\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\"4\\\",\\\"1\\\",\\\"9\\\",\\\".\\\",\\\".\\\",\\\"5\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\"9\\\"]]\", \"[[\\\"8\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\"6\\\",\\\".\\\",\\\".\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\".\\\",\\\"9\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\"],[\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"3\\\"],[\\\"4\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"1\\\"],[\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\"],[\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\"8\\\",\\\".\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\"4\\\",\\\"1\\\",\\\"9\\\",\\\".\\\",\\\".\\\",\\\"5\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\"9\\\"]]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "解数独",
        "translatedContent": "<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>数独的解法需<strong> 遵循如下规则</strong>：</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用&nbsp;<code>'.'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>输入：</strong>board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n<img src=\" https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png\" style=\"height:250px; width:250px\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li>\n\t<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>\n</ul>\n</div>\n</div>\n</div>\n",
        "description": "编写一个程序，通过填充空格来解决数独问题。\n数独的解法需 遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 '.' 表示。",
        "examples": [
          {
            "title": "示例 1",
            "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]",
            "explanation": "",
            "raw_content": "输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n输出：[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示："
          }
        ],
        "constraints": "board.length == 9\nboard[i].length == 9\nboard[i][j] 是一位数字或者 '.'\n题目数据 保证 输入数独仅有一个解",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          },
          {
            "name": "Matrix",
            "nameTranslated": "矩阵",
            "slug": "matrix"
          }
        ],
        "hints": [
          "For each cell, place a valid number and try solving for the remaining empty cells.",
          "If stuck, undo (backtrack) and try another valid number."
        ],
        "exampleTestcases": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "sampleTestCase": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "jsonExampleTestcases": "[\"[[\\\"5\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\"6\\\",\\\".\\\",\\\".\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\".\\\",\\\"9\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\"],[\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"3\\\"],[\\\"4\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"1\\\"],[\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\"],[\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\"8\\\",\\\".\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\"4\\\",\\\"1\\\",\\\"9\\\",\\\".\\\",\\\".\\\",\\\"5\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\"9\\\"]]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "外观数列",
        "translatedContent": "<p>「外观数列」是一个数位字符串序列，由递归公式定义：</p>\n\n<ul>\n\t<li><code>countAndSay(1) = \"1\"</code></li>\n\t<li><code>countAndSay(n)</code> 是&nbsp;<code>countAndSay(n-1)</code> 的行程长度编码。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><a href=\"https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940\">行程长度编码</a>（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串&nbsp;<code>\"3322251\"</code>&nbsp;，我们将&nbsp;<code>\"33\"</code>&nbsp;用&nbsp;<code>\"23\"</code>&nbsp;替换，将&nbsp;<code>\"222\"</code>&nbsp;用&nbsp;<code>\"32\"</code>&nbsp;替换，将&nbsp;<code>\"5\"</code>&nbsp;用&nbsp;<code>\"15\"</code>&nbsp;替换并将&nbsp;<code>\"1\"</code>&nbsp;用&nbsp;<code>\"11\"</code>&nbsp;替换。因此压缩后字符串变为 <code>\"23321511\"</code>。</p>\n\n<p>给定一个整数&nbsp;<code>n</code>&nbsp;，返回&nbsp;<strong>外观数列</strong>&nbsp;的第&nbsp;<code>n</code>&nbsp;个元素。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong>n = 4</p>\n\n<p><strong>输出：</strong>\"1211\"</p>\n\n<p><strong>解释：</strong></p>\n\n<p>countAndSay(1) = \"1\"</p>\n\n<p>countAndSay(2) = \"1\" 的行程长度编码 = \"11\"</p>\n\n<p>countAndSay(3) = \"11\" 的行程长度编码 = \"21\"</p>\n\n<p>countAndSay(4) = \"21\" 的行程长度编码 = \"1211\"</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">n = 1</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">\"1\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>这是基本情况。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>进阶：</strong>你能迭代解决该问题吗？",
        "description": "「外观数列」是一个数位字符串序列，由递归公式定义：\n\ncountAndSay(1) = \"1\"\ncountAndSay(n) 是 countAndSay(n-1) 的行程长度编码。\n\n \n\n\n行程长度编码（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 \"3322251\" ，我们将 \"33\" 用 \"23\" 替换，将 \"222\" 用 \"32\" 替换，将 \"5\" 用 \"15\" 替换并将 \"1\" 用 \"11\" 替换。因此压缩后字符串变为 \"23321511\"。\n给定一个整数 n ，返回 外观数列 的第 n 个元素。",
        "examples": [
          {
            "title": "示例 1",
            "input": "n = 4",
            "output": "\"1211\"",
            "explanation": "countAndSay(1) = \"1\"\ncountAndSay(2) = \"1\" 的行程长度编码 = \"11\"\ncountAndSay(3) = \"11\" 的行程长度编码 = \"21\"\ncountAndSay(4) = \"21\" 的行程长度编码 = \"1211\"",
            "raw_content": "输入：n = 4\n输出：\"1211\"\n解释：\ncountAndSay(1) = \"1\"\ncountAndSay(2) = \"1\" 的行程长度编码 = \"11\"\ncountAndSay(3) = \"11\" 的行程长度编码 = \"21\"\ncountAndSay(4) = \"21\" 的行程长度编码 = \"1211\""
          },
          {
            "title": "示例 2",
            "input": "n = 1",
            "output": "\"1\"",
            "explanation": "这是基本情况。",
            "raw_content": "输入：n = 1\n输出：\"1\"\n解释：\n这是基本情况。"
          }
        ],
        "constraints": "1 <= n <= 30",
        "followUp": "你能迭代解决该问题吗？",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          }
        ],
        "hints": [
          "Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].",
          "Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\".",
          "Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain."
        ],
        "exampleTestcases": "1\n4",
        "sampleTestCase": "1",
        "jsonExampleTestcases": "[\"1\", \"4\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "组合总和",
        "translatedContent": "<p>给你一个 <strong>无重复元素</strong> 的整数数组&nbsp;<code>candidates</code> 和一个目标整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中可以使数字和为目标数&nbsp;<code>target</code> 的 所有<em>&nbsp;</em><strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>\n\n<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。&nbsp;</p>\n\n<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的不同组合数少于 <code>150</code> 个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [2,3,6,7], target = 7\n<strong>输出：</strong>[[2,2,3],[7]]\n<strong>解释：</strong>\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,5], target = 8\n<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2], target = 1\n<strong>输出: </strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n",
        "description": "给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n \n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n示例 2：\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n示例 3：\n\n输入: candidates = [2], target = 1\n输出: []",
        "examples": [
          {
            "title": "示例 1",
            "input": "candidates = [2,3,6,7], target = 7",
            "output": "[[2,2,3],[7]]",
            "explanation": "2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。",
            "raw_content": "输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。"
          },
          {
            "title": "示例 2",
            "input": "candidates = [2,3,5], target = 8",
            "output": "[[2,2,2,2],[2,3,3],[3,5]]",
            "explanation": "",
            "raw_content": "输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]"
          },
          {
            "title": "示例 3",
            "input": "candidates = [2], target = 1",
            "output": "[]",
            "explanation": "",
            "raw_content": "输入: candidates = [2], target = 1\n输出: []"
          }
        ],
        "constraints": "1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\ncandidates 的所有元素 互不相同\n1 <= target <= 40",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          }
        ],
        "hints": [],
        "exampleTestcases": "[2,3,6,7]\n7\n[2,3,5]\n8\n[2]\n1",
        "sampleTestCase": "[2,3,6,7]\n7",
        "jsonExampleTestcases": "[\"[2,3,6,7]\\n7\", \"[2,3,5]\\n8\", \"[2]\\n1\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "组合总和 II",
        "translatedContent": "<p>给定一个候选人编号的集合&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用&nbsp;<strong>一次</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>解集不能包含重复的组合。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,\n<strong>输出:</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,\n<strong>输出:</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
        "description": "给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n注意：解集不能包含重复的组合。 \n \n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n输出:\n[\n[1,2,2],\n[5]\n]",
        "examples": [
          {
            "title": "示例 1",
            "input": "candidates = [10,1,2,7,6,1,5], target = 8,",
            "output": "[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
            "explanation": "",
            "raw_content": "输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
          },
          {
            "title": "示例 2",
            "input": "candidates = [2,5,2,1,2], target = 5,",
            "output": "[\n[1,2,2],\n[5]\n]",
            "explanation": "",
            "raw_content": "输入: candidates = [2,5,2,1,2], target = 5,\n输出:\n[\n[1,2,2],\n[5]\n]"
          }
        ],
        "constraints": "1 <= candidates.length <= 100\n1 <= candidates[i] <= 50\n1 <= target <= 30",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          }
        ],
        "hints": [],
        "exampleTestcases": "[10,1,2,7,6,1,5]\n8\n[2,5,2,1,2]\n5",
        "sampleTestCase": "[10,1,2,7,6,1,5]\n8",
        "jsonExampleTestcases": "[\"[10,1,2,7,6,1,5]\\n8\", \"[2,5,2,1,2]\\n5\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "缺失的第一个正数",
        "translatedContent": "<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>\n请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>1 在数组中，但 2 没有。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的正数 1 没有出现。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "description": "给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,2,0]",
            "output": "3",
            "explanation": "范围 [1,2] 中的数字都在数组中。",
            "raw_content": "输入：nums = [1,2,0]\n输出：3\n解释：范围 [1,2] 中的数字都在数组中。"
          },
          {
            "title": "示例 2",
            "input": "nums = [3,4,-1,1]",
            "output": "2",
            "explanation": "1 在数组中，但 2 没有。",
            "raw_content": "输入：nums = [3,4,-1,1]\n输出：2\n解释：1 在数组中，但 2 没有。"
          },
          {
            "title": "示例 3",
            "input": "nums = [7,8,9,11,12]",
            "output": "1",
            "explanation": "最小的正数 1 没有出现。",
            "raw_content": "输入：nums = [7,8,9,11,12]\n输出：1\n解释：最小的正数 1 没有出现。"
          }
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          }
        ],
        "hints": [
          "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
          "We don't care about duplicates or non-positive integers",
          "Remember that O(2n) = O(n)"
        ],
        "exampleTestcases": "[1,2,0]\n[3,4,-1,1]\n[7,8,9,11,12]",
        "sampleTestCase": "[1,2,0]",
        "jsonExampleTestcases": "[\"[1,2,0]\", \"[3,4,-1,1]\", \"[7,8,9,11,12]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "接雨水",
        "translatedContent": "<p>给定&nbsp;<code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\" /></p>\n\n<pre>\n<strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [4,2,0,3,2,5]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "description": "给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。",
        "examples": [
          {
            "title": "示例 1",
            "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
            "output": "6",
            "explanation": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。",
            "raw_content": "输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。"
          },
          {
            "title": "示例 2",
            "input": "height = [4,2,0,3,2,5]",
            "output": "9",
            "explanation": "",
            "raw_content": "输入：height = [4,2,0,3,2,5]\n输出：9"
          }
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Stack",
            "nameTranslated": "栈",
            "slug": "stack"
          },
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Two Pointers",
            "nameTranslated": "双指针",
            "slug": "two-pointers"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          },
          {
            "name": "Monotonic Stack",
            "nameTranslated": "单调栈",
            "slug": "monotonic-stack"
          }
        ],
        "hints": [],
        "exampleTestcases": "[0,1,0,2,1,0,1,3,2,1,2,1]\n[4,2,0,3,2,5]",
        "sampleTestCase": "[0,1,0,2,1,0,1,3,2,1,2,1]",
        "jsonExampleTestcases": "[\"[0,1,0,2,1,0,1,3,2,1,2,1]\", \"[4,2,0,3,2,5]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "字符串相乘",
        "translatedContent": "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num1 = \"2\", num2 = \"3\"\n<strong>输出:</strong> \"6\"</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num1 = \"123\", num2 = \"456\"\n<strong>输出:</strong> \"56088\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;只能由数字组成。</li>\n\t<li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;都不包含任何前导零，除了数字0本身。</li>\n</ul>\n",
        "description": "给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。",
        "examples": [
          {
            "title": "示例 1",
            "input": "num1 = \"2\", num2 = \"3\"",
            "output": "\"6\"",
            "explanation": "",
            "raw_content": "输入: num1 = \"2\", num2 = \"3\"\n输出: \"6\""
          },
          {
            "title": "示例 2",
            "input": "num1 = \"123\", num2 = \"456\"",
            "output": "\"56088\"",
            "explanation": "",
            "raw_content": "输入: num1 = \"123\", num2 = \"456\"\n输出: \"56088\""
          }
        ],
        "constraints": "1 <= num1.length, num2.length <= 200\nnum1 和 num2 只能由数字组成。\nnum1 和 num2 都不包含任何前导零，除了数字0本身。",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Simulation",
            "nameTranslated": "模拟",
            "slug": "simulation"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"2\"\n\"3\"\n\"123\"\n\"456\"",
        "sampleTestCase": "\"2\"\n\"3\"",
        "jsonExampleTestcases": "[\"\\\"2\\\"\\n\\\"3\\\"\", \"\\\"123\\\"\\n\\\"456\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "通配符匹配",
        "translatedContent": "<div class=\"title__3Vvk\">给你一个输入字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，请你实现一个支持 <code>'?'</code> 和 <code>'*'</code> 匹配规则的通配符匹配：</div>\n\n<ul>\n\t<li class=\"title__3Vvk\"><code>'?'</code> 可以匹配任何单个字符。</li>\n\t<li class=\"title__3Vvk\"><code>'*'</code> 可以匹配任意字符序列（包括空字符序列）。</li>\n</ul>\n\n<div class=\"original__bRMd\">\n<div>\n<p>判定匹配成功的充要条件是：字符模式必须能够 <strong>完全匹配</strong> 输入字符串（而不是部分匹配）。</p>\n</div>\n</div>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>'*' 可以匹配任意字符串。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cb\", p = \"?a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>p</code> 仅由小写英文字母、<code>'?'</code> 或 <code>'*'</code> 组成</li>\n</ul>\n",
        "description": "给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 '?' 和 '*' 匹配规则的通配符匹配：\n\n'?' 可以匹配任何单个字符。\n'*' 可以匹配任意字符序列（包括空字符序列）。\n\n\n\n判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。",
        "examples": [
          {
            "title": "示例 1",
            "input": "s = \"aa\", p = \"a\"",
            "output": "false",
            "explanation": "\"a\" 无法匹配 \"aa\" 整个字符串。",
            "raw_content": "输入：s = \"aa\", p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。"
          },
          {
            "title": "示例 2",
            "input": "s = \"aa\", p = \"*\"",
            "output": "true",
            "explanation": "'*' 可以匹配任意字符串。",
            "raw_content": "输入：s = \"aa\", p = \"*\"\n输出：true\n解释：'*' 可以匹配任意字符串。"
          },
          {
            "title": "示例 3",
            "input": "s = \"cb\", p = \"?a\"",
            "output": "false",
            "explanation": "'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。",
            "raw_content": "输入：s = \"cb\", p = \"?a\"\n输出：false\n解释：'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。"
          }
        ],
        "constraints": "0 <= s.length, p.length <= 2000\ns 仅由小写英文字母组成\np 仅由小写英文字母、'?' 或 '*' 组成",
        "followUp": "",
        "difficulty": "Hard",
        "topicTags": [
          {
            "name": "Greedy",
            "nameTranslated": "贪心",
            "slug": "greedy"
          },
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          }
        ],
        "hints": [],
        "exampleTestcases": "\"aa\"\n\"a\"\n\"aa\"\n\"*\"\n\"cb\"\n\"?a\"",
        "sampleTestCase": "\"aa\"\n\"a\"",
        "jsonExampleTestcases": "[\"\\\"aa\\\"\\n\\\"a\\\"\", \"\\\"aa\\\"\\n\\\"*\\\"\", \"\\\"cb\\\"\\n\\\"?a\\\"\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "跳跃游戏 II",
        "translatedContent": "<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置在下标 0。</p>\n\n<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在索引&nbsp;<code>i</code>&nbsp;处，你可以跳转到任意 <code>(i + j)</code> 处：</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code>&nbsp;且</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>返回到达&nbsp;<code>n - 1</code>&nbsp;的最小跳跃次数。测试用例保证可以到达 <code>n - 1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,1,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。\n&nbsp;    从下标为 0 跳到下标为 1 的位置，跳&nbsp;<code>1</code>&nbsp;步，然后跳&nbsp;<code>3</code>&nbsp;步到达数组的最后一个位置。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,0,1,4]\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>题目保证可以到达&nbsp;<code>n - 1</code></li>\n</ul>\n",
        "description": "给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。\n每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：\n\n0 <= j <= nums[i] 且\ni + j < n\n\n返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [2,3,1,1,4]",
            "output": "2",
            "explanation": "跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。",
            "raw_content": "输入: nums = [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。"
          },
          {
            "title": "示例 2",
            "input": "nums = [2,3,0,1,4]",
            "output": "2",
            "explanation": "",
            "raw_content": "输入: nums = [2,3,0,1,4]\n输出: 2"
          }
        ],
        "constraints": "1 <= nums.length <= 104\n0 <= nums[i] <= 1000\n题目保证可以到达 n - 1",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Greedy",
            "nameTranslated": "贪心",
            "slug": "greedy"
          },
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Dynamic Programming",
            "nameTranslated": "动态规划",
            "slug": "dynamic-programming"
          }
        ],
        "hints": [],
        "exampleTestcases": "[2,3,1,1,4]\n[2,3,0,1,4]",
        "sampleTestCase": "[2,3,1,1,4]",
        "jsonExampleTestcases": "[\"[2,3,1,1,4]\", \"[2,3,0,1,4]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "全排列",
        "translatedContent": "<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "description": "给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
            "explanation": "",
            "raw_content": "输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
          },
          {
            "title": "示例 2",
            "input": "nums = [0,1]",
            "output": "[[0,1],[1,0]]",
            "explanation": "",
            "raw_content": "输入：nums = [0,1]\n输出：[[0,1],[1,0]]"
          },
          {
            "title": "示例 3",
            "input": "nums = [1]",
            "output": "[[1]]",
            "explanation": "",
            "raw_content": "输入：nums = [1]\n输出：[[1]]"
          }
        ],
        "constraints": "1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,2,3]\n[0,1]\n[1]",
        "sampleTestCase": "[1,2,3]",
        "jsonExampleTestcases": "[\"[1,2,3]\", \"[0,1]\", \"[1]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "全排列 II",
        "translatedContent": "<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "description": "给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。",
        "examples": [
          {
            "title": "示例 1",
            "input": "nums = [1,1,2]",
            "output": "[[1,1,2],\n [1,2,1],\n [2,1,1]]",
            "explanation": "",
            "raw_content": "输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n [1,2,1],\n [2,1,1]]"
          },
          {
            "title": "示例 2",
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
            "explanation": "",
            "raw_content": "输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
          }
        ],
        "constraints": "1 <= nums.length <= 8\n-10 <= nums[i] <= 10",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Backtracking",
            "nameTranslated": "回溯",
            "slug": "backtracking"
          },
          {
            "name": "Sorting",
            "nameTranslated": "排序",
            "slug": "sorting"
          }
        ],
        "hints": [],
        "exampleTestcases": "[1,1,2]\n[1,2,3]",
        "sampleTestCase": "[1,1,2]",
        "jsonExampleTestcases": "[\"[1,1,2]\", \"[1,2,3]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "旋转图像",
        "translatedContent": "<p>给定一个 <em>n&nbsp;</em>×&nbsp;<em>n</em> 的二维矩阵&nbsp;<code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n\n<p>你必须在<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"height: 188px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"height: 201px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "description": "给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。",
        "examples": [
          {
            "title": "示例 1",
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "output": "[[7,4,1],[8,5,2],[9,6,3]]",
            "explanation": "",
            "raw_content": "输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]"
          },
          {
            "title": "示例 2",
            "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
            "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
            "explanation": "",
            "raw_content": "输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
          }
        ],
        "constraints": "n == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          },
          {
            "name": "Matrix",
            "nameTranslated": "矩阵",
            "slug": "matrix"
          }
        ],
        "hints": [],
        "exampleTestcases": "[[1,2,3],[4,5,6],[7,8,9]]\n[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "sampleTestCase": "[[1,2,3],[4,5,6],[7,8,9]]",
        "jsonExampleTestcases": "[\"[[1,2,3],[4,5,6],[7,8,9]]\", \"[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "字母异位词分组",
        "translatedContent": "<p>给你一个字符串数组，请你将 <span data-keyword=\"anagram\">字母异位词</span> 组合在一起。可以按任意顺序返回结果列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入:</strong> strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]</p>\n\n<p><strong>输出: </strong>[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]</p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>在 strs 中没有字符串可以通过重新排列来形成 <code>\"bat\"</code>。</li>\n\t<li>字符串 <code>\"nat\"</code> 和 <code>\"tan\"</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>\n\t<li>字符串 <code>\"ate\"</code>&nbsp;，<code>\"eat\"</code>&nbsp;和 <code>\"tea\"</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>\n</ul>\n</div>\n\n<p><strong>示例 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入:</strong> strs = [\"\"]</p>\n\n<p><strong>输出: </strong>[[\"\"]]</p>\n</div>\n\n<p><strong>示例 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入:</strong> strs = [\"a\"]</p>\n\n<p><strong>输出: </strong>[[\"a\"]]</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n",
        "description": "给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。",
        "examples": [
          {
            "title": "示例 1",
            "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
            "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "explanation": "在 strs 中没有字符串可以通过重新排列来形成 \"bat\"。\n字符串 \"nat\" 和 \"tan\" 是字母异位词，因为它们可以重新排列以形成彼此。\n字符串 \"ate\" ，\"eat\" 和 \"tea\" 是字母异位词，因为它们可以重新排列以形成彼此。",
            "raw_content": "输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n解释：\n\n在 strs 中没有字符串可以通过重新排列来形成 \"bat\"。\n字符串 \"nat\" 和 \"tan\" 是字母异位词，因为它们可以重新排列以形成彼此。\n字符串 \"ate\" ，\"eat\" 和 \"tea\" 是字母异位词，因为它们可以重新排列以形成彼此。"
          },
          {
            "title": "示例 2",
            "input": "strs = [\"\"]",
            "output": "[[\"\"]]",
            "explanation": "",
            "raw_content": "输入: strs = [\"\"]\n输出: [[\"\"]]"
          },
          {
            "title": "示例 3",
            "input": "strs = [\"a\"]",
            "output": "[[\"a\"]]",
            "explanation": "",
            "raw_content": "输入: strs = [\"a\"]\n输出: [[\"a\"]]"
          }
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] 仅包含小写字母",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Array",
            "nameTranslated": "数组",
            "slug": "array"
          },
          {
            "name": "Hash Table",
            "nameTranslated": "哈希表",
            "slug": "hash-table"
          },
          {
            "name": "String",
            "nameTranslated": "字符串",
            "slug": "string"
          },
          {
            "name": "Sorting",
            "nameTranslated": "排序",
            "slug": "sorting"
          }
        ],
        "hints": [],
        "exampleTestcases": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n[\"\"]\n[\"a\"]",
        "sampleTestCase": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "jsonExampleTestcases": "[\"[\\\"eat\\\",\\\"tea\\\",\\\"tan\\\",\\\"ate\\\",\\\"nat\\\",\\\"bat\\\"]\", \"[\\\"\\\"]\", \"[\\\"a\\\"]\"]"
      }
    },
    {
      "question": {
        "translatedTitle": "Pow(x, n)",
        "translatedContent": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(<em>x</em>, <em>n</em>)</a>&nbsp;，即计算 <code>x</code> 的整数&nbsp;<code>n</code> 次幂函数（即，<code>x<sup>n</sup></code><sup><span style=\"font-size:10.8333px\"> </span></sup>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = 10\n<strong>输出：</strong>1024.00000\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.10000, n = 3\n<strong>输出：</strong>9.26100\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = -2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code>&nbsp;是一个整数</li>\n\t<li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "description": "实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。",
        "examples": [
          {
            "title": "示例 1",
            "input": "x = 2.00000, n = 10",
            "output": "1024.00000",
            "explanation": "",
            "raw_content": "输入：x = 2.00000, n = 10\n输出：1024.00000"
          },
          {
            "title": "示例 2",
            "input": "x = 2.10000, n = 3",
            "output": "9.26100",
            "explanation": "",
            "raw_content": "输入：x = 2.10000, n = 3\n输出：9.26100"
          },
          {
            "title": "示例 3",
            "input": "x = 2.00000, n = -2",
            "output": "0.25000",
            "explanation": "2-2 = 1/22 = 1/4 = 0.25",
            "raw_content": "输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25"
          }
        ],
        "constraints": "-100.0 < x < 100.0\n-231 <= n <= 231-1\nn 是一个整数\n要么 x 不为零，要么 n > 0 。\n-104 <= xn <= 104",
        "followUp": "",
        "difficulty": "Medium",
        "topicTags": [
          {
            "name": "Recursion",
            "nameTranslated": "递归",
            "slug": "recursion"
          },
          {
            "name": "Math",
            "nameTranslated": "数学",
            "slug": "math"
          }
        ],
        "hints": [],
        "exampleTestcases": "2.00000\n10\n2.10000\n3\n2.00000\n-2",
        "sampleTestCase": "2.00000\n10",
        "jsonExampleTestcases": "[\"2.00000\\n10\", \"2.10000\\n3\", \"2.00000\\n-2\"]"
      }
    }
  ]
}